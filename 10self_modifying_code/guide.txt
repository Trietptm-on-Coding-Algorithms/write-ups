|=--[ Introduction

In principle, self-modifying codes is not really different from "normal" codes,
they are just much less popular. We may notice that any instruction must be fetched, 
decoded and executed by the CPU, that means under view point of the CPU, instructions 
are rather data: an instruction cannot not "run" itself, it must be interpreted 
by the CPU. 

Code and data are always distinguished in both Von Neumann and Harvard architecture 
(we may notice that Harvard architecture even does not allow modifying the memory 
zone for instructions), but we can always write "self-modifying" code if we consider 
"code" as "data".

Beside low-level reasons about performance of self-modifying code in modern CPU(s),
one of reason for which self-modifying code is not popular, is that it is still very
hard to reason (i.e. understanding the semantics of) programs using self-modifying
code. None of popular programming languages supports directly self-modifying code
(but we can always write self-modifying in any Turing-complete language, of course).
Formal semantics of programming languages, proof about programs, program analysis
methods, most are constructed based on models without self-modifying code.


|=--[ Writing self-modifying code

Once we recognize that "code" is nothing but "data", writing self-modifying code is
no different from writing normal code. The execution of a program using self-modifying
code can be separated into stages: there are instructions generating other instructions,
and these instructions can even generated by other instructions. The principles are
presented, for example in [1] for untyped programming languages, or in [2,3] for typedo
languages.

We may notice that code packers [4] can be considered as a simple form of self-modifying
code. This technique is quite popular in malwares and protected binaries.

|=--[ Examples

Since popular programming languages do not support writing directly self-modifying
code, for illustration purpose, we chose assembly to write some examples.

In source files in "src" folders (of both "homework" and "lectures"), we present in 
detail the technical discussions through several examples. For example, "klein.asm" 
is a program where no self-modifying code is applied, self-modifying is then applied 
in next versions "klein_staged", "klein_staged_n", "klein_staged_n1", "klein_staged_n2".

The program implements "insertion sorting" algorithm, it receives inputs from the command
line, sorts these inputs and print result. For example:

./klein 14 21 6 9 17 0 100 20
0 6 9 14 17 20 21 100

Beside looking into the source code, one can directly analyzing the binaries in "bin"
folder, for example "klein_simple" and "klein_staged3", to observe the difficulty of
reversing a program with self-modifying code.

|=--[ References

[1] Ulrik Jorring and William L. Scherlis. Compilers and Staging Transformations.
[2] Walid Taha. Multi-Stage Programming: Its Theory and Applications.
[3] Rowan Davies and Frank Pfenning. A Modal Analysis of Staged Computation.
[4] Kevin A. Roundy and Barton P. Miller. Binary-Code Obfuscations in Prevalent Packer Tools.
