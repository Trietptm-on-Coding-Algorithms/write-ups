%!TEX root = panda.tex
%!TEX program = lualatex

\documentclass{easychair}
\input{format}

\begin{document}

\title{GreHack 2015 - Weak Up Panda}
\titlerunning{GreHack 2015 - Weak Up Panda}

\author{Thanh Dinh Ta\inst{1}}
\authorrunning{Thanh Dinh Ta}

\institute{Verimag}

\clearpage
\maketitle

\section{Reversing}
The challenge is a $64$ bit ELF binary, when executes, it prints \texttt{badboy} and quits. A quick analysis with \texttt{ltrace} reveals that it reads an environment variable named \texttt{INPUT} (cf.~\Cref{fig:unset_input}). So we try to set a value for this variable (our shell is \texttt{fish}\footnote{\url{http://fishshell.com/}}):
\begin{lstlisting}[frame=lines, caption={Setting \texttt{INPUT}}, captionpos=b, boxpos=b, language=bash, label=lst:keygen]
set -x INPUT abcdef
\end{lstlisting}
and execute the crackme again (cf.~\Cref{fig:set_input}); still \texttt{badboy} though. There is no useful information yet, except that there are two \texttt{rand} calls, each followed by a \texttt{malloc}, maybe for storing the returned values of \texttt{rand}(s) (?); but we do not sure at this step \blacksmiley{}.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio]{ltrace_check.png}
    \caption{INPUT is unset}
    \label{fig:unset_input}
  \end{subfigure}%
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio]{ltrace_check_with_input.png}
    \caption{INPUT is set}
    \label{fig:set_input}
  \end{subfigure}
  \caption{Executing crackme with unset/set \texttt{INPUT}}
\end{figure}

We take a more detail analysis by drop this crackme into \texttt{IDA}, the \texttt{main} function can be quickly recognized from the familiar pattern: looking from the entry point, the address of \texttt{main} is passed as the first parameter for \texttt{libc\_start\_main}; here this address is \texttt{0x41806c}. At the first look, the structure of \texttt{main} seems simple, but it is not \frownie{}. The nightmare commence from functions called by \texttt{main}: any of them has a \emph{tail call} to another function, and this called function, in its turn, has also tail to another one, so on and so forth; we even cannot believe into our eyes when seeing the function call graph generated by \texttt{IDA}. 

We try next to run the crackme step-by-step in IDA, but we give up soon since it is too long; moreover the semantics of most functions (in this calling chain) are quite simple; then they do not give useful information. This crackme maybe has intention to push the idea of \emph{continuation passing style} to the extreme.

\paragraph{Automated analysis}
The manual analysis does not work well, so we try an automated approach using our Pintool developed in BinSec project~\autocite{binsec}: this Pintool has capability of tracing only instructions executed in a range of addresses (here we set them as the first and the last address of \texttt{main}: \texttt{0x41806c} and \texttt{0x4181f6}), and tracing only internal instructions of the crackme (i.e.~the instructions of external calls \texttt{rand}, \texttt{malloc}, etc will be not counted). The following sequence shows the numbers of executed instructions where lengths of \texttt{INPUT} is $1, 2, 3, 4, 5, 6, 7, 8$:
\begin{equation*}
  51886, 66187, 80511, \dots, 137771, 168055
\end{equation*}
and if the length of \texttt{INPUT} then the number instructions is always $168055$. The first $7$ numbers form an arithmetic progression with the difference $14301$, but the difference between $7$th to $8$th is $30284$. These observations suggest that the good \texttt{INPUT} should have the length $8$ (or the crackme does consider only $8$ first characters of \texttt{INPUT}).

\section{Differential analysis}
We now focus on values of \texttt{INPUT} with length $8$, but observing that the execution trace of the crackme for this length is $168055$, so manually examining such a number of instructions is not a good idea \smiley{}. Moreover, by manually examining several functions with IDA, we observe that most of them do not compute anything, moreover many of them are  identical!!!. One way to filter out unimportant instructions is to compare the execution traces result in from different values of \texttt{INPUT}. We choose, for example, ``abcdefgh'' and ``HGFEDCBA'', the differences between two traces disclosure how the crackme work.
% ; and \emph{understand immediately how the crackme works}.

Each character of the input is consumed by a loop which starts from \texttt{0x4181b5} (and backs to this address by a \texttt{leave} instruction). The prediction that the crackme considers only first $8$ characters is confirmed by the following instructions (the order of current examined character is stored in \texttt{[rbp - 0x34]}):
\begin{lstlisting}[frame=lines, caption={Checking if length is $8$}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checklength]
0x4181b5  mov eax, dword ptr [rbp-0x34]
0x4181b8  and eax, 0xfffffff7
0x4181bb  mov edx, eax
0x4181bd  mov eax, dword ptr [rbp-0x34]
0x4181c0  xor eax, 0xfffffff7
0x4181c3  mov ecx, eax
0x4181c5  mov eax, dword ptr [rbp-0x34]
0x4181c8  sub eax, 0x8
0x4181cb  and eax, ecx
0x4181cd  or eax, edx
0x4181cf  test eax, eax
\end{lstlisting}
The crackme uses unusual codes to check whether a character is \texttt{NULL} or not (cf.~\Cref{lst:checknull}; the character is stored in \texttt{[rax]}). We note that there are several irrelevant instructions between \texttt{0x418175} and \texttt{0x418183} (maybe for an obfuscation purpose \smiley{})
\begin{lstlisting}[frame=lines, caption={Checking if character is \texttt{NULL}}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checknull]
0x41816d  movzx eax, byte ptr [rax]
0x418170  movsx eax, al
0x418173  not eax
0x418175  mov ecx, eax
...
0x418183  movzx eax, byte ptr [rax]
0x418186  movsx eax, al
0x418189  sub eax, 0x1
0x41818c  and eax, ecx
0x41818e  test eax, eax
\end{lstlisting}

\paragraph{Checksum algorithm}
Each loop consume a character of \texttt{INPUT}, this character and an additional value are used to calculate a checksum; this checksum is used as the additional value for the next loop. In summary, the checksum is calculated by:
\begin{lstlisting}[frame=lines, caption={Calculating checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumcalculation]
\end{lstlisting}
then is verified by (see also~\Cref{lst:checksumverificationcode}):
\begin{lstlisting}[frame=lines, caption={Verifying checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumverification]
\end{lstlisting}

\begin{lstlisting}[frame=lines, caption={Instructions verifying checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumverificationcode]
0x41d74f  mov rdx, qword ptr [rax]
0x41d752  mov rax, 0x122d4d05a4299633
0x41d75c  lea rcx, ptr [rdx+rax*1]
0x41d760  mov rax, qword ptr [rbp-0x8]
0x41d764  mov rdx, qword ptr [rax]
0x41d767  mov rax, 0x122d4d05a4299633
0x41d771  add rax, rdx
0x41d774  sar rax, 0x3f
0x41d778  xor rcx, rax
0x41d77b  mov rax, qword ptr [rbp-0x8]
0x41d77f  mov rdx, qword ptr [rax]
0x41d782  mov rax, 0x122d4d05a4299633
0x41d78c  add rax, rdx
0x41d78f  shr rax, 0x3f
0x41d793  add rax, rcx
0x41d796  sub rax, 0x1
0x41d79a  shr rax, 0x3f
\end{lstlisting}

Once the checksum calculation and verification are known, the calculation for good input is direct. We give a file \texttt{panda.smt2}\footnote{\url{https://github.com/tathanhdinh/write-ups/blob/master/Weak\_Up\_Panda\_GreHack2015/panda.smt2}} of SMT format, use \texttt{Z3} to check satisfiability and interpreted values, we obtain a value for \texttt{INPUT}: \texttt{g!r3h4ck}; that makes the crackme print: \texttt{goodboy}.

\section{Conclusion}

\printbibliography

\end{document}