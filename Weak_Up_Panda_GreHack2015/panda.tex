%!TEX root = panda.tex
%!TEX program = lualatex

\documentclass{easychair}
\input{format}

\begin{document}

\title{GreHack 2015 - Weak Up Panda}
\titlerunning{GreHack 2015 - Weak Up Panda}

\author{Thanh Dinh Ta\inst{1}}
\authorrunning{Thanh Dinh Ta}

\institute{Verimag}

\clearpage
\maketitle

\section{Reversing}
The challenge is a $64$ bit ELF binary, when executes, it prints \texttt{badboy} and quits. A quick analysis with \texttt{ltrace} reveals that it reads an environment variable named \texttt{INPUT} (cf.~\Cref{fig:unset_input}). So we try to set a value for this variable (our shell is \texttt{fish}\footnote{\url{http://fishshell.com/}}):
\begin{lstlisting}[frame=lines, caption={Setting \texttt{INPUT}}, captionpos=b, boxpos=b, language=bash, label=lst:keygen]
set -x INPUT abcdef
\end{lstlisting}
and execute the crackme again (cf.~\Cref{fig:set_input}); still \texttt{badboy} though. There is no useful information yet, except that there are two \texttt{rand} calls, each followed by a \texttt{malloc}, maybe for storing the returned values of \texttt{rand}(s) (?); but we are not sure at this step \smiley{}.

\begin{figure}[ht]
  \centering
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio]{ltrace_check.png}
    \caption{INPUT is unset}
    \label{fig:unset_input}
  \end{subfigure}%
  \begin{subfigure}[b]{0.5\textwidth}
    \centering
    \includegraphics[width=0.9\textwidth,keepaspectratio]{ltrace_check_with_input.png}
    \caption{INPUT is set}
    \label{fig:set_input}
  \end{subfigure}
  \caption{Executing crackme with unset/set \texttt{INPUT}}
\end{figure}

We take a more detail analysis by drop this crackme into \texttt{IDA}, the \texttt{main} function can be quickly recognized from the familiar pattern: looking from the entry point, the address of \texttt{main} is passed as the first parameter for \texttt{libc\_start\_main}; here this address is \texttt{0x41806c}. At the first look, the structure of \texttt{main} seems simple, but it is not. The nightmare is from functions called by \texttt{main}: any of them has a \emph{tail call} to another function, and this called function, in its turn, has also tail to another one, so on and so forth; we even cannot believe into our eyes when seeing the function call graph generated by \texttt{IDA} \frownie{}. By searching for string ``badboy'', we also find the string ``goodboy'' and where it will be printed: this is at the function at \texttt{0x41ce4a}.

We try next to run the crackme step-by-step, but give up soon since it is too long; the semantics of most functions (in this calling chain) are quite simple, then they do not give useful information. Moreover, many of them have exactly the same instructions (this is obviously a code redundancy but we do not understand why the crackme does that). This crackme maybe has intention to push the idea of \emph{continuation passing style} to the extreme\footnote{\url{https://en.wikipedia.org/wiki/Continuation-passing_style}}.

\paragraph{Black-box analysis}
The manual analysis with IDA does not work well, so we try our Pintool of BinSec project~\autocite{binsec}: this tool has capability of tracing only instructions executed in a range of addresses (here we set them as the first and the last address of \texttt{main}: \texttt{0x41806c} and \texttt{0x4181f6}), and tracing only internal instructions of the crackme (i.e.~the instructions of external calls \texttt{rand}, \texttt{malloc}, etc will be not counted). The following sequence shows the numbers of executed instructions where lengths of \texttt{INPUT} is $1, 2, 3, 4, 5, 6, 7, 8$:
\begin{equation*}
  51886, 66187, 80511, \dots, 137771, 168055
\end{equation*}
and if the length of \texttt{INPUT} is superior than $8$ then the corresponding number of executed instructions is always $168055$. The first $7$ numbers form an arithmetic progression with the difference $14301$, but the difference between $7$th to $8$th is $30284$. These observations suggest that the good \texttt{INPUT} should either have the length $8$ or the crackme does examine only $8$ first characters of \texttt{INPUT}). Since the number of executed instructions is stable for lengths superior than $8$ then we bias in favour the idea that there are only $8$ first characters are examined. Considering the numbers of excuted instructions as a \emph{program specification} for synthesizing~\autocite{GulwaniPPDP102}, we can give first an \emph{interpretation} for the crackme:
\begin{lstlisting}[frame=lines, caption={Synthesizing of the crackme}, captionpos=b, boxpos=b, language={C}, label=lst:synthesis]
for (i = 0; i < 8; ++i) {
  if (INPUT[i] == 0) return badboy();
  else fun_xxx(...);
}
if validate_xxx(INPUT, ...) then return goodboy();
else return badboy();
\end{lstlisting}
It might be worth noticing that this interpretation is valid for the observed constraints between values of \texttt{INPUT} and corresponding numbers of executed instructions; but it must be refined (by observing more information) to know whichs values will make the crackme print \texttt{goodboy}. Another case that can happen is the interpretation is not valid (when more information is observed). In both cases, more detail analysis must be carried. 

\section{Differential analysis}
We now focus on values of \texttt{INPUT} with length $8$, but the number of executed instructions for this length is $168055$, manually examining such amount of instructions is not a good idea \smiley{}. Moreover, by manually examining several functions with IDA, we observe that most of them do not compute anything, and  many of them are even  identical!!!. One way to filter out such irrelevant instructions is to compare the execution traces result in from different values of \texttt{INPUT}. We choose, for example, ``abcdefgh'' and ``HGFEDCBA'', the differences between two traces (generated by our Pintool) disclosure how the crackme work.
% ; and \emph{understand immediately how the crackme works}.

Each character of the input is consumed by a loop which starts from \texttt{0x4181b5} (and backs to this address by a \texttt{leave} instruction). The intepretation that the crackme considers only first $8$ characters is validated by the following instructions (the order of current examined character is stored in \texttt{[rbp - 0x34]}) executed in each loop:
\begin{lstlisting}[frame=lines, caption={Checking if length is $8$}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checklength]
0x4181b5  mov eax, dword ptr [rbp-0x34]
0x4181b8  and eax, 0xfffffff7
0x4181bb  mov edx, eax
0x4181bd  mov eax, dword ptr [rbp-0x34]
0x4181c0  xor eax, 0xfffffff7
0x4181c3  mov ecx, eax
0x4181c5  mov eax, dword ptr [rbp-0x34]
0x4181c8  sub eax, 0x8
0x4181cb  and eax, ecx
0x4181cd  or eax, edx
0x4181cf  test eax, eax
\end{lstlisting}
The crackme uses unusual codes to check whether a character is \texttt{NULL} or not (cf.~\Cref{lst:checknull}; the character is stored in \texttt{[rax]}). We note that there are several irrelevant instructions between \texttt{0x418175} and \texttt{0x418183} (maybe for an obfuscation purpose \smiley{})
\begin{lstlisting}[frame=lines, caption={Checking if character is \texttt{NULL}}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checknull]
0x41816d  movzx eax, byte ptr [rax]
0x418170  movsx eax, al
0x418173  not eax
0x418175  mov ecx, eax
...
0x418183  movzx eax, byte ptr [rax]
0x418186  movsx eax, al
0x418189  sub eax, 0x1
0x41818c  and eax, ecx
0x41818e  test eax, eax
\end{lstlisting}

\paragraph{Checksum algorithm}
Each loop consume a character of \texttt{INPUT}, this character and an additional value are used to calculate a checksum; this checksum is used as the additional value for the next loop. In summary, the checksum is calculated by:
\begin{lstlisting}[frame=lines, caption={Calculating checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumcalculation]
\end{lstlisting}
then is verified by (see also~\Cref{lst:checksumverificationcode}):
\begin{lstlisting}[frame=lines, caption={Verifying checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumverification]
\end{lstlisting}

\begin{lstlisting}[frame=lines, caption={Instructions verifying checksum}, captionpos=b, boxpos=b, language={[x86masm]Assembler}, label=lst:checksumverificationcode]
0x41d74f  mov rdx, qword ptr [rax]
0x41d752  mov rax, 0x122d4d05a4299633
0x41d75c  lea rcx, ptr [rdx+rax*1]
0x41d760  mov rax, qword ptr [rbp-0x8]
0x41d764  mov rdx, qword ptr [rax]
0x41d767  mov rax, 0x122d4d05a4299633
0x41d771  add rax, rdx
0x41d774  sar rax, 0x3f
0x41d778  xor rcx, rax
0x41d77b  mov rax, qword ptr [rbp-0x8]
0x41d77f  mov rdx, qword ptr [rax]
0x41d782  mov rax, 0x122d4d05a4299633
0x41d78c  add rax, rdx
0x41d78f  shr rax, 0x3f
0x41d793  add rax, rcx
0x41d796  sub rax, 0x1
0x41d79a  shr rax, 0x3f
\end{lstlisting}

Once the checksum calculation and verification are known, the calculation for good input is direct. We then write file \texttt{panda.smt2}\footnote{\url{https://github.com/tathanhdinh/write-ups/blob/master/Weak\_Up\_Panda\_GreHack2015/panda.smt2}} of SMT format, use \texttt{Z3} to check satisfiability of formulae in the file, then get interpreted values. We obtain a satisfied value for \texttt{INPUT}: \texttt{g!r3h4ck}; that makes the crackme print: \texttt{goodboy}.

\paragraph{Control flow graph reconstruction}
We can also recover the control flow graph of this crackme (cf.~\Cref{fig:cfg}) using tools of BinSec~\autocite{binsec}. The CFG is quite simple (so the obfuscation's purpose is not the CFG) but it might worth noticing that each basic block may contain dozens of thousands instructions.

\begin{figure}[ht]
  \centering
  \includegraphics[height=1\textheight,keepaspectratio]{panda_cfg.pdf}
  \caption{Control flow graph}\label{fig:cfg}
\end{figure}

\section{Conclusion}

\printbibliography

\end{document}